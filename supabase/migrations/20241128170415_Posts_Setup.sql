create table
  public."Posts" (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone not null default now(),
    post_content jsonb not null default '[]'::jsonb,
    author UUID REFERENCES auth.users NOT NULL,
    title text NOT NULL,
    constraint Posts_pkey primary key (id)
  ) tablespace pg_default;

  alter table "public"."Posts" enable row level security;

alter table public."Posts"
add constraint check_post_content check (
  jsonb_matches_schema(
    '{
        "type": "array",
        "items": {
            "type": "object",
            "properties": {
                "id": {
                  "type": "string"
                },
                "index": {
                  "type": "number"
                },
                "title": {
                    "type": "string"
                },
                "timestamp": {
                    "type": "string"
                },
                "markdown": {
                    "type": "string"
                },
                "media": {
                    "type" : "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        }
    }',
    post_content
  )
);


CREATE POLICY
"Can only update own post data."
ON public."Posts"
FOR UPDATE
USING (auth.uid() = author);


CREATE POLICY
"Can only delete own post data."
ON public."Posts"
FOR DELETE
USING (auth.uid() = author);

CREATE POLICY
"Enable insert for authenticated users only"
on "public"."Posts"
to authenticated
with check (true);

create policy "Enable read access for all users"
on "public"."Posts"
as PERMISSIVE
for SELECT
to public
using (
true
);

CREATE FUNCTION
  public.create_post_folder()
  RETURNS TRIGGER AS
  $$
  BEGIN
    raise log 'Creating new folder for post %', NEW.title;

    insert into storage.objects
    (bucket_id, name)
    values
    ('uploads', auth.uid() || '/' || NEW.id ||'/.temp');

    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;


CREATE TRIGGER
  create_new_post_folder
  AFTER INSERT ON public."Posts"
  FOR EACH ROW
  EXECUTE PROCEDURE
    public.create_post_folder();


CREATE FUNCTION
  public.delete_post()
  RETURNS TRIGGER AS
  $$
  BEGIN
    raise log 'Deleting post data %', NEW.id;

    delete from storage.objects
      where

    bucket_id = 'uploads' AND name like auth.uid() || '/' || NEW.id;

    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;


CREATE TRIGGER
  delete_post_trigger
  AFTER DELETE ON public."Posts"
  FOR EACH ROW
  EXECUTE PROCEDURE
    public.delete_post();




CREATE FUNCTION
  public.update_post()
  RETURNS TRIGGER AS
  $$
  BEGIN
    NEW.updated_at = now();
  
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;


CREATE TRIGGER
  update_post_trigger
  BEFORE UPDATE ON public."Posts"
  FOR EACH ROW
  EXECUTE PROCEDURE
    public.update_post();





--- How does moving a folder work at this level???!!!